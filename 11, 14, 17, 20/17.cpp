// Восемь возможностей C++17, которые должен применять каждый разработчик
// https://habr.com/ru/articles/343622/

// 1. Декомпозиция
// декомпозиция std::pair, std::tuple и структуры с помощью нового синтаксиса

auto [title, year] = /*pair, tuple, map или структура. Можно и класс, нужно написать подсказку путём специализации tuple_element, tuple_size и get */

// 2. Автоматический вывод параметров шаблонов
vector v{1,34,34,34,34,34}; // можно! <int> не обязательно!
std::pair user = {"M", 25}; // <std::string, int> не обязательно!
std::tuple user2("M", "Chy", 25);  // <std::string, std::string, int> не обязательно!

// 3. Объявление вложенных пространств имён
namespace product::account::details 
	{ /* ...ваши классы и функции... */ }
	
// 4. Атрибуты nodiscard, fallthrough, maybe_unused
[[fallthrough]] вместо break. выдаст варнинг если fallthrough не во всех условиях в switch-case вместо break
[[nodiscard]] выдаст варнинг для функций, возвращающих код ошибки или владеющий указатель (неважно, умный или нет) если не используется, можно на целый класс
[[maybe_unused]] для переменных, которые нужны только для проверки в assert (отмена варнинга на неиспользуемую переменную)

// 5. Класс string_view для параметров-строк
в параметрах всех функций и методов вместо const string& старайтесь принимать невладеющий string_view по значению
возвращайте из функций и методов владеющий string, как и раньше
будьте осторожны с возвратом string_view из функции: это может привести к проблеме висячих ссылок (англ. dangling pointers)

// 6. Классы optional и variant
отдельная большая тема

// 7. Функции std::size, std::data, std::begin, std::end
std::size работает с массивами и с контейнерами STL, но выдаст ошибку компиляции при попытке передать ей обычный указатель
std::data возвращает изменяемый указателя начало строки, массива или vector<>

// 8. Используйте std::filesystem::path

// 9. Бонусное правило: прекратите переизобретать clamp, int_to_string и string_to_int
to_chars и from_chars